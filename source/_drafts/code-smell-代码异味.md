---
title: code smell(代码异味)
tags: 
- dev
---
Code Smell中文译名一般为“代码异味”，或“代码味道”，它是提示代码中某个地方存在错误的一个暗示，开发人员可以通过这种smell（异味）在代码中追捕到问题。

在计算机编程社区中，code smell代表了任何标志着事物变坏的征兆。它常常标志代码应该被refactored或者全部的设计都应该被reviewed。这个短语出现在 WardsWiki上，它是被Kent Beck杜撰出来的。在refactoring兴起之后，这个短语的使用率骤增。

<!--more-->

判断是否存在code smell经常是主观判断，并且随着语言、开发者、开发理论的不同而存在差异。

经验丰富和知识渊博的开发人员通过对优秀设计有一种“感觉”，他们已经达到一种称之为“无意识能力 （Unconscious Competence）”的状态。也就是说，他们无需思考，只要通过查看代码或一段设计就可以立马对这个项目的代码质量有一种 “感觉”，能够对代码设计的优劣有一个大致的判断。

但大家需要注意，code smell只是一种“暗示”，而非一种“确定”。将某些事物称之为“code smell”并未是一种攻击，它只是一种提示：开发人员需要对项目设计进行更进一步的查看。因此，code smell更多是“直觉的，本能的”。	

## Application-level smells:

1. 重复代码(Duplicate Code)

   代码重复几乎是最常见的异味了。代码重复往往来自于copy-and-paste的编程风格。

2. Contrived complexity

   强制使用过于复杂的设计模式，而简单的设计就已经足够了。


## Class-level smells:

1. 大类(Large Class)

   大类就是你把太多的责任交给了一个类。这里的规则是One Class One。

2. 依恋情节(Featury Envy)

   对其它对象中的数据太感兴趣了

3. 不合适的亲密(Inappropriate Intimacy)

   某些类相互之间太亲密，它们花费了太多的时间去砖研别人的私有部分。对人类而言，我们也许不应该太假正经，但我们应当让自己的类严格遵守禁欲主义。

4. 被拒绝的继承(Refused Bequest)

   父类传下来很多行为和状态，而子类只是用了其中的很小一部分。这通常意味着你的类层次有问题。

5. 惰类(Lazy Class)

   一个干活不多的类。类的维护需要额外的开销，如果一个类承担了太少的责任，应当消除它。

6. 过多的使用常量(Excessive use of literals)

  将常量命名以提高可读性并避免编程错误

7. 圈复杂度(Cyclomatic complexity)

  大量的循环和分支；这可能表明了一个功能需要细分或者尽可能的简化。

8. 数据泥团(Data Clumps)

   某些数据通常像孩子一样成群玩耍：一起出现在很多类的成员变量中，一起出现在许多方法的参数中……，这些数据或许应该自己独立形成对象。

## Method-level smells:

1. 参数太多(Long Parameter List)

    对象含有状态，不需要太多的参数

2. 过长的函数(Long Method)

    它是传统结构化的“遗毒”。一个方法应当具有自我独立的意图，不要把几个意图放在一起，特别注意大类和长方法。

3. 不一致的变化(Divergent Change)

    一个类里面的内容变化率不同。某些状态一个小时变一次，某些则几个月一年才变一次；某些状态因为这方面的原因发生变化，而另一些则因为其他方面的原因变一 次。面向对象的抽象就是把相对不变的和相对变化相隔离。把问题变化的一方面和另一方面相隔离。这使得这些相对不变的可以重用。问题变化的每个方面都可以单 独重用。这种相异变化的共存使得重用非常困难。

4. 散弹式修改(Shotgun Surgery)

    对系统一个地方的改变涉及到其他许多地方的相关改变。这些变化率和变化内容相似的状态和行为通常应当放在同一个类中。

5. 基本类型偏执(Primitive Obsession)

    用类代替原始数据类型。面向对象的新手通常习惯使用几个原始类型的数据来表示一个概念。譬如对于范围，他们会使用两个数字。对于Money，他们会用一个浮点数来表示。因为你没有使用对象来表达问题中存在的概念，这使得代码变的难以理解，解决问题的难度大大增加。好的习惯是扩充语言所能提供原始类型，用小对象来表示范围、金额、 转化率、邮政编码等等。

6. 开关语句(Switch Statement)

   基于常量的开关语句是OO 的大敌，你应当把他变为子类、state 或strategy。

7. 并行继承层次(Parallel Inheritance Hierarchies)

    并行的继承层次是shotgun surgery 的特殊情况。因为当你改变一个层次中的某一个类时，你必须同时改变另外一个层次的并行子类。

8. 投机通则(Speculative Generality)

    一个类实现了从未用到的功能和通用性。通常这样的类或方法唯一的用户是test case。不要犹豫，删除它。

9. 令人迷惑的临时字段(Temporary Field)

    一个对象的属性可能只在某些情况下才有意义。这样的代码将难以理解。专门建立一个对象来持有这样的孤儿属性，把只和他相关的行为移到该类。最常见的是一个特定的算法需要某些只有该算法才有用的变量。

10. 消息链(Message Chain)

  消息链发生于当一个客户向一个对象要求另一个对象，然后客户又向这另一对象要求另一个对象，再向这另一个对象要求另一个对象，如此如此。这时，你需要隐藏分派。

11. 中间人(Middle Man)

    对象的基本特性之一就是封装，而你经常会通过分派去实现封装。但是这一步不能走得太远，如果你发现一个类接口的一大半方法都在做分派，你可能需要移去这个中间人。

12. 异曲同工的类(Alternative Classes with Different Interfaces)

13. 不完整的类库(Incomplete Library Class)

    要建立一个好的类库非常困难。我们大量的程序工作都基于类库实现。然而，如此广泛而又相异的目标对库构建者提出了苛刻的要求。库构建者也不是万能的。有时 候我们会发现库类无法实现我们需要的功能。而直接对库类的修改有非常困难。这时候就需要用各种手段进行Refactoring。

14. 数据类(Data Class)

    对象包括状态和行为。如果一个类只有状态没有行为，那么肯定有什么地方出问题了。

15. 注释(Comments)

    经常觉得要写很多注释表示你的代码难以理解。如果这种感觉太多，表示你需要Refactoring。

FROM:https://en.wikipedia.org/wiki/Code_smell